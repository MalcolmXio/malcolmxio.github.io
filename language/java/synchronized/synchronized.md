# Synchronized

`Synchronized` блок синхронизируется с некоторым объектом. Все блоки, синхронизированные с одним и тем же объектом, могут иметь только один поток, выполняющийся внутри них одновременно. Все остальные потоки, пытающиеся войти в синхронизированный блок, блокируются до тех пор, пока поток внутри синхронизированного блока не выйдет из блока.

Ключевое слово `synchronized` может использоваться для обозначения четырех различных типов блоков:

- Методы экземпляра
- Статические методы
- Блоки кода внутри методов экземпляра
- Блоки кода внутри статических методов

Эти блоки синхронизированы на разных объектах. Какой тип синхронизированного блока вам нужен, зависит от конкретной ситуации.

## Методы экземпляра класса

В качестве монитора выступает экземпляр класса. Если у экземпляра несколько `synchronized` методов, то невозможно параллельное их выполнение несколькими разными потоками, из-за ограничения на захват монитора только одним потоком.

Один поток на один экземпляр класса.

## Статические методы

В качестве монитора выступает класс. Поскольку только один объект класса может существовать в JVM, то только один поток может выполнять статический метод за раз.

Один поток на один объект класса.

## Блок кода внутри обычного метода

```Kotlin
public void log2(String msg1, String msg2){
       synchronized(this){
          log.writeln(msg1);
          log.writeln(msg2);
       }
    }
```

Конструкция `synchronized` заключает объект в круглые скобки. В примере используется `this`, который является экземпляром, для которого вызывается метод `add()`. Объект, взятый в круглые скобки синхронизированной конструкцией, называется монитором. `synchronized` метод экземпляра использует объект, к которому он принадлежит, в качестве монитора.

## Блок кода внутри статического метода

```Kotlin
public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);  
       }
    }
```

## Другие примеры

`synchronized` блок может также выполняться внутри лямбда-выражений и анонимных классов.