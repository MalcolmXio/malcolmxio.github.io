# JMM
## Heap

Heap - используется Java Runtime для выделения памяти под объекты и классы.
Создание нового объекта происходит в куче.

Куча - область работы сборщика мусора.
Любой объект, созданный в куче, имеет глобальный доступ.

## Stack

Stack - область хранения данных, находящаяся в RAM.
Когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе.
Как только метод заканчивает работу, блок также перестает использоваться.

Каждый поток имеет свой стек. Поток имеет доступ только к своему стеку. Создавая поток, можно передать в конструкторе размер стека. Но JVM может нас не послушаться.

![](/language/java/jmm/res/java-memory-model-3.png)

## Архитектура памяти на аппаратном уровне

![](/language/java/jmm/res/java-memory-model-4.png)

Современный компьютер часто имеет в своем составе 2 или более процессоров. Некоторые из этих процессоров также могут иметь несколько ядер. Дело в том, что на современном компьютере с 2 или более процессорами возможно одновременное выполнение более чем одного потока. Каждый процессор способен запускать один поток в любой момент времени. Это означает, что если ваше Java-приложение многопоточно, то один поток на процессор может выполняться одновременно (concurrently) внутри вашего Java-приложения.

Каждый центральный процессор содержит набор регистров, которые, по сути, являются встроенной памятью центрального процессора. Центральный процессор может выполнять операции с этими регистрами намного быстрее, чем с переменными в основной памяти (RAM).

Каждый центральный процессор также может иметь уровень кэш-памяти. Центральный процессор может получить доступ к своей кэш-памяти намного быстрее, чем к основной памяти, но обычно не так быстро, как он может получить доступ к своим внутренним регистрам. Таким образом, кэш-память процессора находится где-то посередине между скоростью работы внутренних регистров и основной памятью. Некоторые процессоры могут иметь несколько уровней кэширования (уровень 1, уровень 2, уровень 3), но это не так важно знать, чтобы понять, как модель памяти Java взаимодействует с памятью. Важно знать, что процессоры могут иметь какой-либо уровень кэш-памяти.

Компьютер также содержит область основной памяти (RAM). Все процессоры могут получать доступ к основной памяти. Область основной памяти обычно намного больше, чем кэш-память процессоров.

Как правило, когда процессору требуется доступ к основной памяти, он считывает часть основной памяти в свой кэш процессора. Он может даже считывать часть кэша в свои внутренние регистры и затем выполнять над ним операции. Когда процессору нужно записать результат обратно в основную память, он сбрасывает значение из своего внутреннего регистра в кэш-память и в какой-то момент сбрасывает значение обратно в основную память.

Значения, хранящиеся в кэш-памяти, обычно сбрасываются обратно в основную память, когда процессору необходимо сохранить что-то еще в кэш-памяти. Кэш процессора может одновременно записывать данные в часть своей памяти и очищать часть своей памяти за один раз. Ему не нужно считывать / записывать полный кэш каждый раз, когда он обновляется. Обычно кэш обновляется в меньших блоках памяти, называемых "строками кэша". Одна или несколько строк кэша могут быть считаны в кэш-память, и одна или несколько строк кэша могут быть снова сброшены обратно в основную память.

## Связь между JMM и аппаратной частью

Архитектура аппаратной памяти не проводит различия между стеками потоков и кучей. На аппаратном уровне как стеки потоков, так и куча находятся в основной памяти. Части стеков потоков и кучи иногда могут присутствовать в кэшах процессора и во внутренних регистрах процессора.

![](/language/java/jmm/res/java-memory-model-5.png)

Когда объекты и переменные могут храниться в различных областях памяти компьютера, могут возникнуть определенные проблемы. Двумя основными проблемами являются:

- видимость обновлений потока (записей) в общие переменные
- гонка состояний при чтении, проверке и записи общих переменных

### Видимость изменений общих для нескольких потоков переменных

Если два или более потоков совместно используют объект, обновления этого объекта, сделанные одним потоком, могут быть невидимы для других потоков.

Представьте, что общий объект изначально хранится в основной памяти. Поток, запущенный на CPU 1, затем считывает общий объект в свой кэш процессора. Там он вносит изменения в общий объект. До тех пор, пока кэш процессора не будет сброшен обратно в основную память, измененная версия общего объекта не будет видна потокам, запущенным на других процессорах. Таким образом, каждый поток может в конечном итоге получить свою собственную копию общего объекта, причем каждая копия находится в другом кэше процессора.

![](/language/java/jmm/res/java-memory-model-6.png)

Для решения этой проблемы можно воспользоваться ключевым словом #Volatile, которое обеспечивает чтение/запись напрямую из главной памяти, в обход кэша процессора.

### Гонка состояний

Если 2 и более потока обновляют значение общей переменной, можно получить некорректное состояние этой переменной.

Например:
Поток 1 считывает в кэш значение переменной. Поток 2 делает то же самое в свой кэш. Далее, поток 1 увеличивает значение переменной на 1 и поток 2 делает то же самое.
Если бы программа выполнялась последовательно, инкремент произошел бы 2 раза. Однако, в случае параллельного выполнения без синхронизации, значение переменной увеличится на 1.

![](/language/java/jmm/res/java-memory-model-7.png)

Для решения данной проблемы, можно воспользоваться блоком синхронизации #Synchronized. Этот блок гарантирует, что только один поток будет иметь доступ к критической секции внутри блока. Также гарантируется, что все переменные, используемые внутри блока будут считываться из основной памяти. Когда поток выйдет из блока синхронизации, все обновленные значения переменных будут возвращены в основной память немедленно, не зависимо от того, объявлены ли они `volatile` или нет.
