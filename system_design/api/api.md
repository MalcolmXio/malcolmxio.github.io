# API

## Real time notifications

Варианты уведомления пользователя о каких-то событиях в реальном времени.

### Push

Плюсы:

- легко реализовать
- можно обрабатывать, когда приложение в фоне

Минусы:

- не всегда можно обработать пуш (риск потери)
- скорость (можно прождать минуту)
- зависит от чужой библиотеки (FCM)
- пользователь может запретить пуши

### HTTP polling

Периодические обращения к серверу. Наибольшая проблема - ненужная нагрузка на сеть.

- short polling
  - плюсы:
    - легко реализовать. Недорого, если время между запросами небольшое
    - не требуется постоянное соединение
  - минусы:
    - задержка в получении может достигать времени между запросами
    - оверхед по созданию соединений
- long polling
  - плюсы:
    - мгновенное получение апдейта
  - минусы:
    - более сложно реализовать. большая нагрузка на сервер
    - держит постоянное соединение до тех пор, пока сервер не ответит

### SSE (server sent events)

Позволяет клиенту обрабатывать поток событий через HTTP соединение, без необходимости поллинга

- плюсы:
  - траффик в реальном времени, без задержек
- минусы:
  - необходимость держать постоянное соединение

### Web sockets

Предоставляет двунаправленный канал связи между клиентом и сервером

плюсы:

- может передавать бинарные данные и текстовые

минусы:

- более сложная настройка по сравнению с поллингом, sse
- необходимость поддерживать постоянное соединение

## Протоколы взаимодействия с бэкендом

### REST

REST - текстоориентированный протокол. Наиболее популярный выбор для CRUD операций.

Плюсы:

- легко изучить, применять на практике
- легко кешировать использую встроенный механизм кеширования в HTTP
- низкая связность между клиентом и сервером

Минусы:

- каждый запрос требует создания нового подключения
- нет четкого контракта. Сложно проверить валидность данных на клиенте
- стейтлесс - нужны приседания, чтобы работать с сессией
- лишняя метадата в запросах + хедеры

### GraphQL

Позволяет запрашивать данные из нескольких ресурсов через один эндпоинт.

Плюсы:

- клиенты могут валидировать данные и из формат
- большая кастомизируемость. Клиенты могут запрашивать специфические данные, уменьшая нагрузку на траффик
- двунаправленное взаимодействие через GraphQL Subscriptions (аналог WebSockets)

Минусы:

- сложная реализация на бекенде
- клиенты становятся сильно связаны с бекендом
- производительность запроса = минимально производительному сервису (в случае если данные берутся из нескольких сервисов)
- нет кеширования (GraphQL использует всего одну конечную точку, что не позволяет следовать спецификации HTTP-кеширования. Это очень важно, так как кеширование уменьшает объем трафика.)

### WebSocket

Двунаправленный канал свящи через одно TCP соединение

Плюсы:

- соединеине в реальном времени
- текстовый и бинарный формат передачи данных

Минусы:

- необходимо поддержание постоянного соединения
- нет четкого контракта - сложно проверить валидность данных на клиенте
- количестов активных соединений на одном сервере ограничено 65 000

### gRPC

Фреймворк для удаленного вызова процедур. Работает на базе HTTP/2. Поддерживает двунаправленный канал передачи данных в рамках одного физического соединения.

Плюсы:

- легковесные бинарные сообщения
- есть четкий контракт. Встроенная кодлгенерация через Protobuf
- поддержка event-driven архитектуры
- возможность выполнения нескольких параллельных запросов

Минусы:

- ограниченная поддержка браузерами
- нечитаемый для человека формат передачи
- сложен для изучения
