# Generics

В контексте коллекций:
G - способ сказать компилятору, что я хочу работать с каким-то типом. С каким именно - я не знаю. Пусть решает тот, кто мной пользуется. Ты можешь проверить, что в меня приходит этот тип или из меня уходит.

Списки - ковариантны (на самом деле не совсем: @UnsafeVariance для четырех методов). Из него мы только возвращаем. У него есть только `out` позиция.

Если мы только читаем из объекта, то логично было бы иметь возможность оперировать с супертипом типа:

```Kotlin
class Producer<out T> {
    fun produce(): T
}

Any - супертип String
Producer <Any> - супертип Producer <String>
```

Это **ковариантность**.

Если мы осуществляем запись в объект, то логично было бы иметь возможность передавать параметром подтип типа:

```Kotlin
class Consumer<in T> {
    fun consume(value: T): Unit
}

Any - супертип String
Consumer<String> - супертип Consumer<Any>
```

Это **контравариантность**.

MutableList - инвариантны. Т.к. Мы можем как складывать в in - позицию, так и доставать из out - позиции.

```Kotlin
Any - супертип String
MutableList <Any> - не супертип MutableList <String> и не подтип
```

 Массивы в Kotlin инвариантны!

## Star projections

 Когда нам все-равно с каким типом мы работаем.

 Пример:

 ```Kotlin
 val list: MutableList<*> = mutableListOf(1, 2, 3)
 val element: Any? = list[0] // Когда достаем, то будет тип Any?
 
 list.add(1) // The integer literal does not conform to the expected type Nothing.
 
 Когда что-то кладем - ожидается Nothing. Но создать экземпляр Nothing нельзя
 ```

## Почему происходит стирание типа?

Потому что в старой java не было generics. Нужно было уметь исполнять код на старых java машинах, поэтому до компиляции есть тип, после - всегда лежит Object/Any?.
